from findtargetoperon import read_gff
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq
import pandas as pd


def remove_transposaes(seq_record: SeqRecord, insertions: pd.DataFrame):
    seq = seq_record.seq
    
    pos = 0
    delta = 0
    
    deletions = [] # new index, removed string, delta_at_current_pos
    cleaned = []
    
    for index, insertion in insertions.iterrows():
        start = insertion['start']
        end = insertion['end']
        
        if start < pos:
            start = pos
        
        clean = seq[pos:start]
        
        cleaned.append(clean)
        transposone_seq = seq[start:end]
        assert len(transposone_seq) == end - start
        new_delta = delta + len(transposone_seq)

        deletions.append((start - delta, transposone_seq, delta))
        
        delta = new_delta
        pos = end
        
    cleaned.append(seq[pos:len(seq)])
        
    clean_seq = Seq(''.join(str(s) for s in cleaned))
    
    sr = seq
    sc = clean_seq
    
    assert len(sr) - len(sc) - delta == 0
    
    return clean_seq, deletions


def rebuild(seq: Seq, deletions):
    out = []
    pos = 0
    for insert_idx, insertion, delta in deletions:
        prev = seq[pos:insert_idx]
        out.append(prev)
        out.append(insertion)
        pos = insert_idx
        
    out.append(seq[pos:len(seq)])
    
    return Seq(''.join(str(s) for s in out))


def _splice(args):
    secs = list(SeqIO.parse(args.fasta, "fasta"))
    annotation = read_gff(args.gff)
    annotation = annotation.sort_values(by='start')
    insertions = annotation['type'] == 'insertion_sequence'
    annotation = annotation[insertions]
    
    annotation = annotation.reset_index(drop=True)

    sequences = []
    dels = []

    for seq_record in secs:
        this_seq = annotation['seq_id'] == seq_record.id
        cs, ds = remove_transposaes(seq_record, annotation[this_seq])
        
        s = seq_record[:1]
        s.seq = cs
        s.description = s.description + ', transposon free'
        
        sequences.append(s)
        dels.append(ds)
        
        # Just checking if we'll be able to rebuild sequence later
        reb = rebuild(cs, ds)
        assert len(seq_record.seq) == len(reb)
        assert seq_record.seq == reb

    SeqIO.write(sequences, args.output, format='fasta')
    print(f'{args.output}')
    for sequence, ds in zip(sequences, dels):
        file = f'{args.output}_{sequence.id}.rebuild.csv'
        with open(file, 'w') as out:
            for idx, seq, delta in ds:
                print(f'{idx},{seq},{delta}', file=out)
        print(file)
        
                
        
    


def _rebuild(args):
    pass


def main():
    import argparse
    
    parser = argparse.ArgumentParser()
    subs = parser.add_subparsers(required=True)
    
    splice = subs.add_parser('cut')
    splice.add_argument('fasta', help='complete genome')
    splice.add_argument('gff', help='transposon annotation (with insertion_sequence)')
    splice.add_argument('-o', '--output', help='out transposone-free .fna + .fna.restore.csv')
    splice.set_defaults(func=_splice)
    
    rebuild = subs.add_parser('rebuild')
    rebuild.add_argument('fasta', help='transposone-free genome')
    rebuild.add_argument('restore', help='restore file (was generated by `splice`)')
    rebuild.add_argument('--gff', help='annotation to be changed')
    rebuild.add_argument('-o', '--output', help='new annotation and rebuilt genome')
    rebuild.set_defaults(func=_rebuild)
    
    args = parser.parse_args()
    
    return args.func(args)






if __name__ == '__main__':
    main()